generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Player {
  id        Int      @id @default(autoincrement())
  openid    String   @unique
  name      String?
  avatar    String?  @db.LongText
  gender    String?  // '男' or '女'
  birthday  DateTime?
  region    String?  // Province-City-District string or just City
  realName  String?
  idCard    String?  @unique // Ensure one ID Card per player account? Or allow multiples? "Bound to ID card" implies uniqueness or grouping. Let's make it unique to prevent duplicates.
  phone     String?
  points    Int      @default(0)
  role      String   @default("USER") // USER, ADMIN
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  results   TournamentResult[]
  // applications PlayerApplication[]  // Removed implicitly named relation
  applicationsAsPlayer PlayerApplication[] @relation("Applicant")
  applicationsAsPartner PlayerApplication[] @relation("Partner")
  refereeOf TournamentReferee[]
  gamesAsPlayer1 MatchGame[] @relation("Player1")
  gamesAsPlayer2 MatchGame[] @relation("Player2")
  gamesAsPartner1 MatchGame[] @relation("Partner1")
  gamesAsPartner2 MatchGame[] @relation("Partner2")
}

model MatchGame {
  id           Int        @id @default(autoincrement())
  tournamentId Int
  groupId      Int?
  player1Id    Int
  player2Id    Int
  partner1Id   Int?       // Partner for Player 1
  partner2Id   Int?       // Partner for Player 2
  score1       String?    // Changed to String to support sets like "6-4" or just "6"
  score2       String?
  status       String     @default("PENDING") // PENDING, COMPLETED
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  tournament   Tournament @relation(fields: [tournamentId], references: [id])
  group        MatchGroup? @relation(fields: [groupId], references: [id])
  player1      Player     @relation("Player1", fields: [player1Id], references: [id])
  player2      Player     @relation("Player2", fields: [player2Id], references: [id])
  partner1     Player?    @relation("Partner1", fields: [partner1Id], references: [id])
  partner2     Player?    @relation("Partner2", fields: [partner2Id], references: [id])
}

model AdminUser {
  id        Int      @id @default(autoincrement())
  username  String   @unique
  password  String
  role      String   @default("ADMIN") // ADMIN, SUPER_ADMIN
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  auditLogs AuditLog[]
}

model PlayerApplication {
  id           Int        @id @default(autoincrement())
  playerId     Int
  partnerId    Int?       // Optional partner for doubles
  tournamentId Int?       // Optional for now to avoid migration issues with existing data, but logic should enforce it
  realName     String
  phone        String
  idCard       String
  project      String?
  bio          String?    @db.Text
  files        String?    @db.Text // JSON string for file URLs
  status       String     @default("PENDING") // PENDING, APPROVED, REJECTED
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  player       Player     @relation("Applicant", fields: [playerId], references: [id])
  partner      Player?    @relation("Partner", fields: [partnerId], references: [id])
  tournament   Tournament? @relation(fields: [tournamentId], references: [id])
  auditLogs    AuditLog[]
}

model AuditLog {
  id            Int               @id @default(autoincrement())
  adminId       Int
  applicationId Int
  action        String            // APPROVED, REJECTED
  comment       String?
  createdAt     DateTime          @default(now())
  admin         AdminUser         @relation(fields: [adminId], references: [id])
  application   PlayerApplication @relation(fields: [applicationId], references: [id])
}

model Tournament {
  id          Int      @id @default(autoincrement())
  name        String
  location    String
  region      String? // Province-City or just City
  category    String? // e.g. '周赛', '月赛', '公开赛'
  level       String? // e.g. '2.5', '3.0', '1000'
  latitude    Float?
  longitude   Float?
  startTime   DateTime
  registrationStart DateTime? // 报名开始时间
  registrationEnd   DateTime? // 报名截止时间
  drawSize          Int?      // 签位数量
  fee               Int?      // 报名费用 (元/人)
  matchType         String?   // '男单','男双','女单','女双','混双','不限'
  description String?
  rules       String?
  withdrawalNotice String? @db.Text // 退赛须知
  contact     String?  // 联系方式
  status      String   @default("PENDING") // PENDING, ONGOING, COMPLETED
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  results     TournamentResult[]
  applications PlayerApplication[]
  referees    TournamentReferee[]
  games       MatchGame[]
  groups      MatchGroup[]
}

model MatchGroup {
  id           Int        @id @default(autoincrement())
  tournamentId Int
  title        String
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  
  tournament   Tournament @relation(fields: [tournamentId], references: [id])
  games        MatchGame[]
}

model TournamentResult {
  id           Int        @id @default(autoincrement())
  tournamentId Int
  playerId     Int
  rank         Int?
  pointsChange Int        @default(0)
  tournament   Tournament @relation(fields: [tournamentId], references: [id])
  player       Player     @relation(fields: [playerId], references: [id])
  
  @@unique([tournamentId, playerId])
}

model TournamentReferee {
  tournamentId Int
  playerId     Int
  tournament   Tournament @relation(fields: [tournamentId], references: [id])
  player       Player     @relation(fields: [playerId], references: [id])

  @@id([tournamentId, playerId])
}
